#include "stm8s103f3p6.h"
#include <stdio.h>
#include <stdint.h>

// --- UART Defines and Functions ---
#define USART_SR_TXE   (1 << 7)
#define USART_CR2_TEN  (1 << 3)
#define GPIO_PIN_5     (1 << 5)

void USART1_Init(void) {
    GPIOD->DDR |= GPIO_PIN_5;
    GPIOD->CR1 |= GPIO_PIN_5;
    USART1->BRR2 = 0x03;
    USART1->BRR1 = 0x68;
    USART1->CR1 = 0x00;
    USART1->CR2 = USART_CR2_TEN;
}
/*
int putchar(int c) {
    if (c == '\n') putchar('\r');  // Add carriage return for terminals
    while (!(USART1->SR & (1 << 7)));  // Wait until TXE (Transmit Data Register Empty)
    USART1->DR = c;
    return c;
}*/
int putchar(int c) {
    if (c == '\n') {
        while (!(USART1->SR & USART_SR_TXE));
        USART1->DR = '\r';
    }
    while (!(USART1->SR & USART_SR_TXE));
    USART1->DR = (uint8_t)c;
    return c;
}



// --- NEC Protocol Defines and Globals ---
#define NEC_PULSE_TOLERANCE 250 // Increased tolerance
#define NEC_AGC_PULSE       9000
#define NEC_AGC_SPACE       4500
#define NEC_REPEAT_SPACE    2250
#define NEC_ONE_SPACE       1687
#define NEC_ZERO_SPACE      562

// Receiver state machine
enum {
    NEC_STATE_IDLE,
    NEC_STATE_AGC_PULSE,
    NEC_STATE_AGC_SPACE,
    NEC_STATE_DATA
};

volatile uint8_t nec_state = NEC_STATE_IDLE;
volatile uint8_t nec_bit_count = 0;
volatile uint32_t nec_decoded_data = 0;
volatile uint8_t nec_data_ready = 0;

// --- Timer 2 for Microsecond Timing ---
void TIM2_Init(void) {
    // f_master = 16MHz. Prescaler of 16 (2^4) gives 1MHz timer clock (1us period).
    TIM2->PSCR = 0x04;
    TIM2->ARRH = 0xFF; // Set auto-reload to max
    TIM2->ARRL = 0xFF;
    TIM2->CR1 |= (1 << 0); // Enable Timer2
}

// --- External Interrupt on PD3 ---
void EXTI_Init(void) {
    // Configure PD3 as Input with Pull-up and Interrupt
    GPIOD->DDR &= ~(1 << 3); // Input
    GPIOD->CR1 |= (1 << 3);  // Pull-up enabled
    GPIOD->CR2 |= (1 << 3);  // Interrupt enabled

    // Configure EXTI for Port D to trigger on falling edge
    EXTI->CR2 = (1 << 3); // PDIS[1:0] = 10 -> Falling edge only
}

// --- Interrupt Service Routine for Port D ---
// The interrupt vector for EXTI Port D is 8.
void EXTI_PORTD_IRQHandler(void) __interrupt(8) {
    GPIOC->ODR ^= (1 << 7);
    uint16_t time_us = (TIM2->CNTRH << 8) | TIM2->CNTRL;
    TIM2->CNTRH = 0; // Reset timer
    TIM2->CNTRL = 0;
    switch (nec_state) {
        case NEC_STATE_IDLE:
            // First falling edge: Start of AGC pulse
            EXTI->CR2 = (1 << 3) | (1 << 2); // Change to Rising edge
            nec_state = NEC_STATE_AGC_PULSE;
            break;

        case NEC_STATE_AGC_PULSE:
            // Rising edge after AGC pulse
            if ((time_us > (NEC_AGC_PULSE - NEC_PULSE_TOLERANCE)) && (time_us < (NEC_AGC_PULSE + NEC_PULSE_TOLERANCE))) {
                EXTI->CR2 = (1 << 3); // Change back to Falling edge
                nec_state = NEC_STATE_AGC_SPACE;
            } else { nec_state = NEC_STATE_IDLE; } // Error, reset
            break;

        case NEC_STATE_AGC_SPACE:
            // Falling edge after space
            if ((time_us > (NEC_AGC_SPACE - NEC_PULSE_TOLERANCE)) && (time_us < (NEC_AGC_SPACE + NEC_PULSE_TOLERANCE))) {
                // Normal data packet
                nec_bit_count = 0;
                nec_decoded_data = 0;
                EXTI->CR2 = (1 << 3) | (1 << 2); // Change to Rising edge
                nec_state = NEC_STATE_DATA;
            } else if ((time_us > (NEC_REPEAT_SPACE - NEC_PULSE_TOLERANCE)) && (time_us < (NEC_REPEAT_SPACE + NEC_PULSE_TOLERANCE))) {
                // Repeat code
                nec_decoded_data = 0xFFFFFFFF; // Special value for repeat
                nec_data_ready = 1;
                nec_state = NEC_STATE_IDLE;
            } else { nec_state = NEC_STATE_IDLE; } // Error, reset
            break;

        case NEC_STATE_DATA:
            // Toggle edge detection for each bit
            EXTI->CR2 ^= (1 << 2); 
            
            // Only decode after the space (when pin is low again)
            if (!(GPIOD->IDR & (1 << 3))) { 
                if ((time_us > (NEC_ONE_SPACE - NEC_PULSE_TOLERANCE)) && (time_us < (NEC_ONE_SPACE + NEC_PULSE_TOLERANCE))) {
                    nec_decoded_data |= (1UL << nec_bit_count); // It's a '1'
                } else if (!((time_us > (NEC_ZERO_SPACE - NEC_PULSE_TOLERANCE)) && (time_us < (NEC_ZERO_SPACE + NEC_PULSE_TOLERANCE)))) {
                    nec_state = NEC_STATE_IDLE; // Error, invalid space
                    break;
                }
                
                nec_bit_count++;
                if (nec_bit_count == 32) {
                    nec_data_ready = 1;
                    nec_state = NEC_STATE_IDLE;
                }
            }
            break;
    }
    GPIOC->ODR ^= (1 << 7);
}

// --- Main ---
void main(void) {
    __asm__("sim"); // Disable interrupts during setup
    
    CLK->CKDIVR = 0x00; // Set system clock to 16MHz
   
    GPIOC->DDR |= (1 << 7);
    GPIOC->CR1 |= (1 << 7);
    // Initialize peripherals
    USART1_Init();
    TIM2_Init();
    EXTI_Init();
    
    __asm__("rim"); // Enable interrupts globally

    printf("Bare-Metal NEC IR Receiver Ready...\n");

    while (1) {
        if (nec_data_ready) {
            __asm__("sim"); // Disable interrupts while processing data
            
            if (nec_decoded_data == 0xFFFFFFFF) {
                printf("REPEAT CODE\n");
            } else {
                uint8_t address = (nec_decoded_data >> 0) & 0xFF;
                uint8_t inv_address = (nec_decoded_data >> 8) & 0xFF;
                uint8_t command = (nec_decoded_data >> 16) & 0xFF;
                uint8_t inv_command = (nec_decoded_data >> 24) & 0xFF;
                
                printf("ADDR: 0x%02X, CMD: 0x%02X", address, command);
                
                // Error checking
                if ((uint8_t)(address + inv_address) != 0xFF || (uint8_t)(command + inv_command) != 0xFF) {
                    printf(" (Error!)");
                }
                printf("\n");
            }
            
            nec_data_ready = 0;
            __asm__("rim"); // Re-enable interrupts
        }
    }
}
