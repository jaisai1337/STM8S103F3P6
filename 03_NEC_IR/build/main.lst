                                      1 ;--------------------------------------------------------
                                      2 ; File Created by SDCC : free open source ANSI-C Compiler
                                      3 ; Version 4.2.0 #13081 (Linux)
                                      4 ;--------------------------------------------------------
                                      5 	.module main
                                      6 	.optsdcc -mstm8
                                      7 	
                                      8 ;--------------------------------------------------------
                                      9 ; Public variables in this module
                                     10 ;--------------------------------------------------------
                                     11 	.globl _main
                                     12 	.globl _TIM2_Update_IRQHandler
                                     13 	.globl _EXTI_PORTD_IRQHandler
                                     14 	.globl _IR_GPIO_Init
                                     15 	.globl _TIM2_Init
                                     16 	.globl _USART1_Init
                                     17 	.globl _puts
                                     18 	.globl _printf
                                     19 	.globl _ir_data_ready
                                     20 	.globl _ir_bit_count
                                     21 	.globl _ir_data
                                     22 	.globl _ir_state
                                     23 	.globl _putchar
                                     24 ;--------------------------------------------------------
                                     25 ; ram data
                                     26 ;--------------------------------------------------------
                                     27 	.area DATA
                                     28 ;--------------------------------------------------------
                                     29 ; ram data
                                     30 ;--------------------------------------------------------
                                     31 	.area INITIALIZED
      000000                         32 _ir_state::
      000000                         33 	.ds 1
      000001                         34 _ir_data::
      000001                         35 	.ds 4
      000005                         36 _ir_bit_count::
      000005                         37 	.ds 1
      000006                         38 _ir_data_ready::
      000006                         39 	.ds 1
                                     40 ;--------------------------------------------------------
                                     41 ; Stack segment in internal ram
                                     42 ;--------------------------------------------------------
                                     43 	.area	SSEG
      000000                         44 __start__stack:
      000000                         45 	.ds	1
                                     46 
                                     47 ;--------------------------------------------------------
                                     48 ; absolute external ram data
                                     49 ;--------------------------------------------------------
                                     50 	.area DABS (ABS)
                                     51 
                                     52 ; default segment ordering for linker
                                     53 	.area HOME
                                     54 	.area GSINIT
                                     55 	.area GSFINAL
                                     56 	.area CONST
                                     57 	.area INITIALIZER
                                     58 	.area CODE
                                     59 
                                     60 ;--------------------------------------------------------
                                     61 ; interrupt vector
                                     62 ;--------------------------------------------------------
                                     63 	.area HOME
      000000                         64 __interrupt_vect:
      000000 82v00u00u00             65 	int s_GSINIT ; reset
      000004 82 00 00 00             66 	int 0x000000 ; trap
      000008 82 00 00 00             67 	int 0x000000 ; int0
      00000C 82 00 00 00             68 	int 0x000000 ; int1
      000010 82 00 00 00             69 	int 0x000000 ; int2
      000014 82 00 00 00             70 	int 0x000000 ; int3
      000018 82 00 00 00             71 	int 0x000000 ; int4
      00001C 82 00 00 00             72 	int 0x000000 ; int5
      000020 82v00u00u49             73 	int _EXTI_PORTD_IRQHandler ; int6
      000024 82 00 00 00             74 	int 0x000000 ; int7
      000028 82 00 00 00             75 	int 0x000000 ; int8
      00002C 82 00 00 00             76 	int 0x000000 ; int9
      000030 82 00 00 00             77 	int 0x000000 ; int10
      000034 82 00 00 00             78 	int 0x000000 ; int11
      000038 82 00 00 00             79 	int 0x000000 ; int12
      00003C 82v00u01u4F             80 	int _TIM2_Update_IRQHandler ; int13
                                     81 ;--------------------------------------------------------
                                     82 ; global & static initialisations
                                     83 ;--------------------------------------------------------
                                     84 	.area HOME
                                     85 	.area GSINIT
                                     86 	.area GSFINAL
                                     87 	.area GSINIT
      000000                         88 __sdcc_init_data:
                                     89 ; stm8_genXINIT() start
      000000 AEr00r00         [ 2]   90 	ldw x, #l_DATA
      000003 27 07            [ 1]   91 	jreq	00002$
      000005                         92 00001$:
      000005 72 4FuFFuFF      [ 1]   93 	clr (s_DATA - 1, x)
      000009 5A               [ 2]   94 	decw x
      00000A 26 F9            [ 1]   95 	jrne	00001$
      00000C                         96 00002$:
      00000C AEr00r00         [ 2]   97 	ldw	x, #l_INITIALIZER
      00000F 27 09            [ 1]   98 	jreq	00004$
      000011                         99 00003$:
      000011 D6uFFuFF         [ 1]  100 	ld	a, (s_INITIALIZER - 1, x)
      000014 D7uFFuFF         [ 1]  101 	ld	(s_INITIALIZED - 1, x), a
      000017 5A               [ 2]  102 	decw	x
      000018 26 F7            [ 1]  103 	jrne	00003$
      00001A                        104 00004$:
                                    105 ; stm8_genXINIT() end
                                    106 	.area GSFINAL
      000000 CCr00r40         [ 2]  107 	jp	__sdcc_program_startup
                                    108 ;--------------------------------------------------------
                                    109 ; Home
                                    110 ;--------------------------------------------------------
                                    111 	.area HOME
                                    112 	.area HOME
      000040                        113 __sdcc_program_startup:
      000040 CCr01r66         [ 2]  114 	jp	_main
                                    115 ;	return from main will return to caller
                                    116 ;--------------------------------------------------------
                                    117 ; code
                                    118 ;--------------------------------------------------------
                                    119 	.area CODE
                                    120 ;	src/main.c: 38: void USART1_Init(void) {
                                    121 ;	-----------------------------------------
                                    122 ;	 function USART1_Init
                                    123 ;	-----------------------------------------
      000000                        124 _USART1_Init:
                                    125 ;	src/main.c: 39: GPIOD->DDR |= (1 << 5);  // Set PD5 as output
      000000 72 1A 50 11      [ 1]  126 	bset	0x5011, #5
                                    127 ;	src/main.c: 40: GPIOD->CR1 |= (1 << 5);  // Push-pull
      000004 72 1A 50 12      [ 1]  128 	bset	0x5012, #5
                                    129 ;	src/main.c: 43: USART1->BRR2 = 0x03;
      000008 35 03 52 33      [ 1]  130 	mov	0x5233+0, #0x03
                                    131 ;	src/main.c: 44: USART1->BRR1 = 0x68;
      00000C 35 68 52 32      [ 1]  132 	mov	0x5232+0, #0x68
                                    133 ;	src/main.c: 46: USART1->CR2 |= (1 << 3);  // TEN: Enable TX
      000010 72 16 52 35      [ 1]  134 	bset	0x5235, #3
                                    135 ;	src/main.c: 47: }
      000014 81               [ 4]  136 	ret
                                    137 ;	src/main.c: 50: int putchar(int c) {
                                    138 ;	-----------------------------------------
                                    139 ;	 function putchar
                                    140 ;	-----------------------------------------
      000015                        141 _putchar:
                                    142 ;	src/main.c: 51: if (c == '\n') putchar('\r');
      000015 A3 00 0A         [ 2]  143 	cpw	x, #0x000a
      000018 26 07            [ 1]  144 	jrne	00103$
      00001A 89               [ 2]  145 	pushw	x
      00001B AE 00 0D         [ 2]  146 	ldw	x, #0x000d
      00001E AD F5            [ 4]  147 	callr	_putchar
      000020 85               [ 2]  148 	popw	x
                                    149 ;	src/main.c: 52: while (!(USART1->SR & (1 << 7))); // Wait for TXE
      000021                        150 00103$:
      000021 C6 52 30         [ 1]  151 	ld	a, 0x5230
      000024 2A FB            [ 1]  152 	jrpl	00103$
                                    153 ;	src/main.c: 53: USART1->DR = c;
      000026 9F               [ 1]  154 	ld	a, xl
      000027 C7 52 31         [ 1]  155 	ld	0x5231, a
                                    156 ;	src/main.c: 54: return c;
                                    157 ;	src/main.c: 55: }
      00002A 81               [ 4]  158 	ret
                                    159 ;	src/main.c: 58: void TIM2_Init(void) {
                                    160 ;	-----------------------------------------
                                    161 ;	 function TIM2_Init
                                    162 ;	-----------------------------------------
      00002B                        163 _TIM2_Init:
                                    164 ;	src/main.c: 60: CLK->PCKENR1 |= (1 << 5);
      00002B 72 1A 50 C7      [ 1]  165 	bset	0x50c7, #5
                                    166 ;	src/main.c: 63: TIM2->PSCR = 0x04; // 2^4 = 16
      00002F 35 04 53 0E      [ 1]  167 	mov	0x530e+0, #0x04
                                    168 ;	src/main.c: 66: TIM2->IER |= (1 << 0);
      000033 72 10 53 03      [ 1]  169 	bset	0x5303, #0
                                    170 ;	src/main.c: 67: }
      000037 81               [ 4]  171 	ret
                                    172 ;	src/main.c: 70: void IR_GPIO_Init(void) {
                                    173 ;	-----------------------------------------
                                    174 ;	 function IR_GPIO_Init
                                    175 ;	-----------------------------------------
      000038                        176 _IR_GPIO_Init:
                                    177 ;	src/main.c: 72: GPIOD->DDR &= ~IR_PIN_MASK; // Input
      000038 72 17 50 11      [ 1]  178 	bres	0x5011, #3
                                    179 ;	src/main.c: 73: GPIOD->CR1 |= IR_PIN_MASK;  // Pull-up enabled
      00003C 72 16 50 12      [ 1]  180 	bset	0x5012, #3
                                    181 ;	src/main.c: 74: GPIOD->CR2 |= IR_PIN_MASK;  // Interrupt enabled
      000040 72 16 50 13      [ 1]  182 	bset	0x5013, #3
                                    183 ;	src/main.c: 77: EXTI->CR1 = (2 << 6); // 10 = Falling edge only for Port D
      000044 35 80 50 A0      [ 1]  184 	mov	0x50a0+0, #0x80
                                    185 ;	src/main.c: 78: }
      000048 81               [ 4]  186 	ret
                                    187 ;	src/main.c: 81: void EXTI_PORTD_IRQHandler(void) __interrupt(6) {
                                    188 ;	-----------------------------------------
                                    189 ;	 function EXTI_PORTD_IRQHandler
                                    190 ;	-----------------------------------------
      000049                        191 _EXTI_PORTD_IRQHandler:
      000049 52 04            [ 2]  192 	sub	sp, #4
                                    193 ;	src/main.c: 84: uint16_t pulse_width = (TIM2->CNTRH << 8) | TIM2->CNTRL;
      00004B C6 53 0C         [ 1]  194 	ld	a, 0x530c
      00004E 95               [ 1]  195 	ld	xh, a
      00004F 0F 02            [ 1]  196 	clr	(0x02, sp)
      000051 C6 53 0D         [ 1]  197 	ld	a, 0x530d
      000054 0F 03            [ 1]  198 	clr	(0x03, sp)
      000056 1A 02            [ 1]  199 	or	a, (0x02, sp)
      000058 02               [ 1]  200 	rlwa	x
      000059 1A 03            [ 1]  201 	or	a, (0x03, sp)
      00005B 95               [ 1]  202 	ld	xh, a
      00005C 1F 03            [ 2]  203 	ldw	(0x03, sp), x
                                    204 ;	src/main.c: 85: TIM2->CNTRH = 0;
      00005E 35 00 53 0C      [ 1]  205 	mov	0x530c+0, #0x00
                                    206 ;	src/main.c: 86: TIM2->CNTRL = 0;
      000062 35 00 53 0D      [ 1]  207 	mov	0x530d+0, #0x00
                                    208 ;	src/main.c: 88: switch (ir_state) {
      000066 C6u00u00         [ 1]  209 	ld	a, _ir_state+0
      000069 A1 04            [ 1]  210 	cp	a, #0x04
      00006B 23 03            [ 2]  211 	jrule	00187$
      00006D CCr01r4C         [ 2]  212 	jp	00130$
      000070                        213 00187$:
                                    214 ;	src/main.c: 99: if (pulse_width > NEC_START_PULSE_MIN && pulse_width < NEC_START_PULSE_MAX) {
      000070 16 03            [ 2]  215 	ldw	y, (0x03, sp)
                                    216 ;	src/main.c: 88: switch (ir_state) {
      000072 5F               [ 1]  217 	clrw	x
      000073 97               [ 1]  218 	ld	xl, a
      000074 58               [ 2]  219 	sllw	x
      000075 DEu00u79         [ 2]  220 	ldw	x, (#00188$, x)
      000078 FC               [ 2]  221 	jp	(x)
      000079                        222 00188$:
      000079r00r83                  223 	.dw	#00101$
      00007Br00r92                  224 	.dw	#00102$
      00007Dr00rAC                  225 	.dw	#00107$
      00007Fr00rD0                  226 	.dw	#00112$
      000081r00rE8                  227 	.dw	#00117$
                                    228 ;	src/main.c: 89: case STATE_IDLE:
      000083                        229 00101$:
                                    230 ;	src/main.c: 91: TIM2->CR1 |= (1 << 0); // Start timer
      000083 72 10 53 00      [ 1]  231 	bset	0x5300, #0
                                    232 ;	src/main.c: 92: ir_state = STATE_START_PULSE;
      000087 35 01u00u00      [ 1]  233 	mov	_ir_state+0, #0x01
                                    234 ;	src/main.c: 94: EXTI->CR1 = (3 << 6); // 11 = Rising and falling for Port D
      00008B 35 C0 50 A0      [ 1]  235 	mov	0x50a0+0, #0xc0
                                    236 ;	src/main.c: 95: break;
      00008F CCr01r4C         [ 2]  237 	jp	00130$
                                    238 ;	src/main.c: 97: case STATE_START_PULSE:
      000092                        239 00102$:
                                    240 ;	src/main.c: 99: if (pulse_width > NEC_START_PULSE_MIN && pulse_width < NEC_START_PULSE_MAX) {
      000092 90 A3 1F 40      [ 2]  241 	cpw	y, #0x1f40
      000096 23 0D            [ 2]  242 	jrule	00104$
      000098 90 A3 27 10      [ 2]  243 	cpw	y, #0x2710
      00009C 24 07            [ 1]  244 	jrnc	00104$
                                    245 ;	src/main.c: 100: ir_state = STATE_START_SPACE;
      00009E 35 02u00u00      [ 1]  246 	mov	_ir_state+0, #0x02
      0000A2 CCr01r4C         [ 2]  247 	jp	00130$
      0000A5                        248 00104$:
                                    249 ;	src/main.c: 102: ir_state = STATE_IDLE; // Error, reset
      0000A5 72 5Fu00u00      [ 1]  250 	clr	_ir_state+0
                                    251 ;	src/main.c: 104: break;
      0000A9 CCr01r4C         [ 2]  252 	jp	00130$
                                    253 ;	src/main.c: 106: case STATE_START_SPACE:
      0000AC                        254 00107$:
                                    255 ;	src/main.c: 108: if (pulse_width > NEC_START_SPACE_MIN && pulse_width < NEC_START_SPACE_MAX) {
      0000AC 90 A3 0F A0      [ 2]  256 	cpw	y, #0x0fa0
      0000B0 23 18            [ 2]  257 	jrule	00109$
      0000B2 90 A3 13 88      [ 2]  258 	cpw	y, #0x1388
      0000B6 24 12            [ 1]  259 	jrnc	00109$
                                    260 ;	src/main.c: 109: ir_state = STATE_BIT_PULSE;
      0000B8 35 03u00u00      [ 1]  261 	mov	_ir_state+0, #0x03
                                    262 ;	src/main.c: 110: ir_bit_count = 0;
      0000BC 72 5Fu00u05      [ 1]  263 	clr	_ir_bit_count+0
                                    264 ;	src/main.c: 111: ir_data = 0;
      0000C0 5F               [ 1]  265 	clrw	x
      0000C1 CFu00u03         [ 2]  266 	ldw	_ir_data+2, x
      0000C4 CFu00u01         [ 2]  267 	ldw	_ir_data+0, x
      0000C7 CCr01r4C         [ 2]  268 	jp	00130$
      0000CA                        269 00109$:
                                    270 ;	src/main.c: 113: ir_state = STATE_IDLE; // Error, reset
      0000CA 72 5Fu00u00      [ 1]  271 	clr	_ir_state+0
                                    272 ;	src/main.c: 115: break;
      0000CE 20 7C            [ 2]  273 	jra	00130$
                                    274 ;	src/main.c: 117: case STATE_BIT_PULSE:
      0000D0                        275 00112$:
                                    276 ;	src/main.c: 119: if (pulse_width > NEC_BIT_PULSE_MIN && pulse_width < NEC_BIT_PULSE_MAX) {
      0000D0 90 A3 01 90      [ 2]  277 	cpw	y, #0x0190
      0000D4 23 0C            [ 2]  278 	jrule	00114$
      0000D6 90 A3 02 BC      [ 2]  279 	cpw	y, #0x02bc
      0000DA 24 06            [ 1]  280 	jrnc	00114$
                                    281 ;	src/main.c: 120: ir_state = STATE_BIT_SPACE;
      0000DC 35 04u00u00      [ 1]  282 	mov	_ir_state+0, #0x04
      0000E0 20 6A            [ 2]  283 	jra	00130$
      0000E2                        284 00114$:
                                    285 ;	src/main.c: 122: ir_state = STATE_IDLE; // Error, reset
      0000E2 72 5Fu00u00      [ 1]  286 	clr	_ir_state+0
                                    287 ;	src/main.c: 124: break;
      0000E6 20 64            [ 2]  288 	jra	00130$
                                    289 ;	src/main.c: 126: case STATE_BIT_SPACE:
      0000E8                        290 00117$:
                                    291 ;	src/main.c: 128: ir_data >>= 1; // Shift right to make space for the new bit (MSB first)
      0000E8 72 54u00u01      [ 1]  292 	srl	_ir_data+0
      0000EC 72 56u00u02      [ 1]  293 	rrc	_ir_data+1
      0000F0 72 56u00u03      [ 1]  294 	rrc	_ir_data+2
      0000F4 72 56u00u04      [ 1]  295 	rrc	_ir_data+3
                                    296 ;	src/main.c: 130: if (pulse_width > NEC_LOGIC_1_SPACE_MIN && pulse_width < NEC_LOGIC_1_SPACE_MAX) {
      0000F8 1E 03            [ 2]  297 	ldw	x, (0x03, sp)
      0000FA A3 05 DC         [ 2]  298 	cpw	x, #0x05dc
      0000FD 23 1C            [ 2]  299 	jrule	00123$
      0000FF A3 07 08         [ 2]  300 	cpw	x, #0x0708
      000102 24 17            [ 1]  301 	jrnc	00123$
                                    302 ;	src/main.c: 131: ir_data |= 0x80000000; // It's a '1'
      000104 90 CEu00u03      [ 2]  303 	ldw	y, _ir_data+2
      000108 C6u00u02         [ 1]  304 	ld	a, _ir_data+1
      00010B 97               [ 1]  305 	ld	xl, a
      00010C C6u00u01         [ 1]  306 	ld	a, _ir_data+0
      00010F AA 80            [ 1]  307 	or	a, #0x80
      000111 95               [ 1]  308 	ld	xh, a
      000112 90 CFu00u03      [ 2]  309 	ldw	_ir_data+2, y
      000116 CFu00u01         [ 2]  310 	ldw	_ir_data+0, x
      000119 20 10            [ 2]  311 	jra	00124$
      00011B                        312 00123$:
                                    313 ;	src/main.c: 132: } else if (pulse_width > NEC_LOGIC_0_SPACE_MIN && pulse_width < NEC_LOGIC_0_SPACE_MAX) {
      00011B A3 01 90         [ 2]  314 	cpw	x, #0x0190
      00011E 23 05            [ 2]  315 	jrule	00119$
      000120 A3 02 BC         [ 2]  316 	cpw	x, #0x02bc
      000123 25 06            [ 1]  317 	jrc	00124$
      000125                        318 00119$:
                                    319 ;	src/main.c: 135: ir_state = STATE_IDLE; // Pulse width error
      000125 72 5Fu00u00      [ 1]  320 	clr	_ir_state+0
                                    321 ;	src/main.c: 136: break;
      000129 20 21            [ 2]  322 	jra	00130$
      00012B                        323 00124$:
                                    324 ;	src/main.c: 139: ir_bit_count++;
      00012B 72 5Cu00u05      [ 1]  325 	inc	_ir_bit_count+0
                                    326 ;	src/main.c: 140: if (ir_bit_count == 32) {
      00012F C6u00u05         [ 1]  327 	ld	a, _ir_bit_count+0
      000132 A1 20            [ 1]  328 	cp	a, #0x20
      000134 26 12            [ 1]  329 	jrne	00127$
                                    330 ;	src/main.c: 142: ir_data_ready = 1;
      000136 35 01u00u06      [ 1]  331 	mov	_ir_data_ready+0, #0x01
                                    332 ;	src/main.c: 143: ir_state = STATE_IDLE;
      00013A 72 5Fu00u00      [ 1]  333 	clr	_ir_state+0
                                    334 ;	src/main.c: 144: TIM2->CR1 &= ~(1 << 0); // Stop timer
      00013E 72 11 53 00      [ 1]  335 	bres	0x5300, #0
                                    336 ;	src/main.c: 145: EXTI->CR1 = (2 << 6);  // Reset EXTI back to falling edge only
      000142 35 80 50 A0      [ 1]  337 	mov	0x50a0+0, #0x80
      000146 20 04            [ 2]  338 	jra	00130$
      000148                        339 00127$:
                                    340 ;	src/main.c: 147: ir_state = STATE_BIT_PULSE; // Ready for the next bit pulse
      000148 35 03u00u00      [ 1]  341 	mov	_ir_state+0, #0x03
                                    342 ;	src/main.c: 150: }
      00014C                        343 00130$:
                                    344 ;	src/main.c: 151: }
      00014C 5B 04            [ 2]  345 	addw	sp, #4
      00014E 80               [11]  346 	iret
                                    347 ;	src/main.c: 154: void TIM2_Update_IRQHandler(void) __interrupt(13) {
                                    348 ;	-----------------------------------------
                                    349 ;	 function TIM2_Update_IRQHandler
                                    350 ;	-----------------------------------------
      00014F                        351 _TIM2_Update_IRQHandler:
                                    352 ;	src/main.c: 155: if (TIM2->SR1 & (1 << 0)) { // Check if it's an update interrupt
      00014F C6 53 04         [ 1]  353 	ld	a, 0x5304
      000152 44               [ 1]  354 	srl	a
      000153 24 10            [ 1]  355 	jrnc	00103$
                                    356 ;	src/main.c: 157: ir_state = STATE_IDLE;
      000155 72 5Fu00u00      [ 1]  357 	clr	_ir_state+0
                                    358 ;	src/main.c: 158: TIM2->CR1 &= ~(1 << 0); // Stop timer
      000159 72 11 53 00      [ 1]  359 	bres	0x5300, #0
                                    360 ;	src/main.c: 159: EXTI->CR1 = (2 << 6);  // Reset EXTI back to falling edge only
      00015D 35 80 50 A0      [ 1]  361 	mov	0x50a0+0, #0x80
                                    362 ;	src/main.c: 160: TIM2->SR1 &= ~(1 << 0); // Clear the interrupt flag
      000161 72 11 53 04      [ 1]  363 	bres	0x5304, #0
      000165                        364 00103$:
                                    365 ;	src/main.c: 162: }
      000165 80               [11]  366 	iret
                                    367 ;	src/main.c: 165: void main(void) {
                                    368 ;	-----------------------------------------
                                    369 ;	 function main
                                    370 ;	-----------------------------------------
      000166                        371 _main:
      000166 52 0B            [ 2]  372 	sub	sp, #11
                                    373 ;	src/main.c: 167: CLK->CKDIVR = 0x00;
      000168 35 00 50 C6      [ 1]  374 	mov	0x50c6+0, #0x00
                                    375 ;	src/main.c: 170: USART1_Init();
      00016C CDr00r00         [ 4]  376 	call	_USART1_Init
                                    377 ;	src/main.c: 171: IR_GPIO_Init();
      00016F CDr00r38         [ 4]  378 	call	_IR_GPIO_Init
                                    379 ;	src/main.c: 172: TIM2_Init();
      000172 CDr00r2B         [ 4]  380 	call	_TIM2_Init
                                    381 ;	src/main.c: 175: __asm__("rim");
      000175 9A               [ 1]  382 	rim
                                    383 ;	src/main.c: 177: printf("\n\nSTM8S IR Receiver Ready\n");
      000176 AEr00r00         [ 2]  384 	ldw	x, #(___str_1+0)
      000179 CDr00r00         [ 4]  385 	call	_puts
                                    386 ;	src/main.c: 179: while (1) {
      00017C                        387 00111$:
                                    388 ;	src/main.c: 180: if (ir_data_ready) {
      00017C C6u00u06         [ 1]  389 	ld	a, _ir_data_ready+0
      00017F 27 FB            [ 1]  390 	jreq	00111$
                                    391 ;	src/main.c: 184: uint32_t temp = ir_data;
      000181 CEu00u03         [ 2]  392 	ldw	x, _ir_data+2
      000184 1F 03            [ 2]  393 	ldw	(0x03, sp), x
      000186 CEu00u01         [ 2]  394 	ldw	x, _ir_data+0
      000189 1F 01            [ 2]  395 	ldw	(0x01, sp), x
                                    396 ;	src/main.c: 185: uint32_t reversed_data = 0;
      00018B 5F               [ 1]  397 	clrw	x
      00018C 1F 0A            [ 2]  398 	ldw	(0x0a, sp), x
      00018E 1F 08            [ 2]  399 	ldw	(0x08, sp), x
                                    400 ;	src/main.c: 186: for(int i = 0; i < 32; i++) {
      000190 5F               [ 1]  401 	clrw	x
      000191 1F 06            [ 2]  402 	ldw	(0x06, sp), x
      000193                        403 00114$:
      000193 1E 06            [ 2]  404 	ldw	x, (0x06, sp)
      000195 A3 00 20         [ 2]  405 	cpw	x, #0x0020
      000198 2E 43            [ 1]  406 	jrsge	00103$
                                    407 ;	src/main.c: 187: if((temp >> i) & 1) {
      00019A 1E 03            [ 2]  408 	ldw	x, (0x03, sp)
      00019C 16 01            [ 2]  409 	ldw	y, (0x01, sp)
      00019E 7B 07            [ 1]  410 	ld	a, (0x07, sp)
      0001A0 27 06            [ 1]  411 	jreq	00157$
      0001A2                        412 00156$:
      0001A2 90 54            [ 2]  413 	srlw	y
      0001A4 56               [ 2]  414 	rrcw	x
      0001A5 4A               [ 1]  415 	dec	a
      0001A6 26 FA            [ 1]  416 	jrne	00156$
      0001A8                        417 00157$:
      0001A8 54               [ 2]  418 	srlw	x
      0001A9 24 2B            [ 1]  419 	jrnc	00115$
                                    420 ;	src/main.c: 188: reversed_data |= (1UL << (31-i));
      0001AB 7B 07            [ 1]  421 	ld	a, (0x07, sp)
      0001AD 6B 05            [ 1]  422 	ld	(0x05, sp), a
      0001AF A6 1F            [ 1]  423 	ld	a, #0x1f
      0001B1 10 05            [ 1]  424 	sub	a, (0x05, sp)
      0001B3 5F               [ 1]  425 	clrw	x
      0001B4 5C               [ 1]  426 	incw	x
      0001B5 90 5F            [ 1]  427 	clrw	y
      0001B7 4D               [ 1]  428 	tnz	a
      0001B8 27 06            [ 1]  429 	jreq	00160$
      0001BA                        430 00159$:
      0001BA 58               [ 2]  431 	sllw	x
      0001BB 90 59            [ 2]  432 	rlcw	y
      0001BD 4A               [ 1]  433 	dec	a
      0001BE 26 FA            [ 1]  434 	jrne	00159$
      0001C0                        435 00160$:
      0001C0 9F               [ 1]  436 	ld	a, xl
      0001C1 1A 0B            [ 1]  437 	or	a, (0x0b, sp)
      0001C3 6B 0B            [ 1]  438 	ld	(0x0b, sp), a
      0001C5 9E               [ 1]  439 	ld	a, xh
      0001C6 1A 0A            [ 1]  440 	or	a, (0x0a, sp)
      0001C8 6B 0A            [ 1]  441 	ld	(0x0a, sp), a
      0001CA 90 9F            [ 1]  442 	ld	a, yl
      0001CC 1A 09            [ 1]  443 	or	a, (0x09, sp)
      0001CE 6B 09            [ 1]  444 	ld	(0x09, sp), a
      0001D0 90 9E            [ 1]  445 	ld	a, yh
      0001D2 1A 08            [ 1]  446 	or	a, (0x08, sp)
      0001D4 6B 08            [ 1]  447 	ld	(0x08, sp), a
      0001D6                        448 00115$:
                                    449 ;	src/main.c: 186: for(int i = 0; i < 32; i++) {
      0001D6 1E 06            [ 2]  450 	ldw	x, (0x06, sp)
      0001D8 5C               [ 1]  451 	incw	x
      0001D9 1F 06            [ 2]  452 	ldw	(0x06, sp), x
      0001DB 20 B6            [ 2]  453 	jra	00114$
      0001DD                        454 00103$:
                                    455 ;	src/main.c: 192: uint8_t address = (reversed_data >> 24) & 0xFF;
      0001DD 7B 08            [ 1]  456 	ld	a, (0x08, sp)
      0001DF 6B 04            [ 1]  457 	ld	(0x04, sp), a
                                    458 ;	src/main.c: 193: uint8_t not_address = (reversed_data >> 16) & 0xFF;
      0001E1 7B 09            [ 1]  459 	ld	a, (0x09, sp)
      0001E3 6B 05            [ 1]  460 	ld	(0x05, sp), a
                                    461 ;	src/main.c: 194: uint8_t command = (reversed_data >> 8) & 0xFF;
      0001E5 7B 0A            [ 1]  462 	ld	a, (0x0a, sp)
      0001E7 6B 06            [ 1]  463 	ld	(0x06, sp), a
                                    464 ;	src/main.c: 195: uint8_t not_command = reversed_data & 0xFF;
      0001E9 7B 0B            [ 1]  465 	ld	a, (0x0b, sp)
      0001EB 6B 07            [ 1]  466 	ld	(0x07, sp), a
                                    467 ;	src/main.c: 198: if ((uint8_t)~address == not_address && (uint8_t)~command == not_command) {
      0001ED 7B 04            [ 1]  468 	ld	a, (0x04, sp)
      0001EF 43               [ 1]  469 	cpl	a
      0001F0 11 05            [ 1]  470 	cp	a, (0x05, sp)
      0001F2 26 27            [ 1]  471 	jrne	00105$
      0001F4 7B 06            [ 1]  472 	ld	a, (0x06, sp)
      0001F6 43               [ 1]  473 	cpl	a
      0001F7 11 07            [ 1]  474 	cp	a, (0x07, sp)
      0001F9 26 20            [ 1]  475 	jrne	00105$
                                    476 ;	src/main.c: 199: printf("OK -> Addr: 0x%02X, Cmd: 0x%02X, Raw: 0x%08lX\n", address, command, reversed_data);
      0001FB 5F               [ 1]  477 	clrw	x
      0001FC 7B 06            [ 1]  478 	ld	a, (0x06, sp)
      0001FE 97               [ 1]  479 	ld	xl, a
      0001FF 7B 04            [ 1]  480 	ld	a, (0x04, sp)
      000201 0F 06            [ 1]  481 	clr	(0x06, sp)
      000203 16 0A            [ 2]  482 	ldw	y, (0x0a, sp)
      000205 90 89            [ 2]  483 	pushw	y
      000207 16 0A            [ 2]  484 	ldw	y, (0x0a, sp)
      000209 90 89            [ 2]  485 	pushw	y
      00020B 89               [ 2]  486 	pushw	x
      00020C 88               [ 1]  487 	push	a
      00020D 7B 0D            [ 1]  488 	ld	a, (0x0d, sp)
      00020F 88               [ 1]  489 	push	a
      000210 4Br1A            [ 1]  490 	push	#<(___str_2+0)
      000212 4Bs00            [ 1]  491 	push	#((___str_2+0) >> 8)
      000214 CDr00r00         [ 4]  492 	call	_printf
      000217 5B 0A            [ 2]  493 	addw	sp, #10
      000219 20 0F            [ 2]  494 	jra	00106$
      00021B                        495 00105$:
                                    496 ;	src/main.c: 201: printf("Error -> Raw: 0x%08lX\n", reversed_data);
      00021B 1E 0A            [ 2]  497 	ldw	x, (0x0a, sp)
      00021D 89               [ 2]  498 	pushw	x
      00021E 1E 0A            [ 2]  499 	ldw	x, (0x0a, sp)
      000220 89               [ 2]  500 	pushw	x
      000221 4Br49            [ 1]  501 	push	#<(___str_3+0)
      000223 4Bs00            [ 1]  502 	push	#((___str_3+0) >> 8)
      000225 CDr00r00         [ 4]  503 	call	_printf
      000228 5B 06            [ 2]  504 	addw	sp, #6
      00022A                        505 00106$:
                                    506 ;	src/main.c: 204: ir_data_ready = 0; // Clear the flag
      00022A 72 5Fu00u06      [ 1]  507 	clr	_ir_data_ready+0
                                    508 ;	src/main.c: 207: }
      00022E CCr01r7C         [ 2]  509 	jp	00111$
                                    510 	.area CODE
                                    511 	.area CONST
                                    512 	.area CONST
      000000                        513 ___str_1:
      000000 0A                     514 	.db 0x0a
      000001 0A                     515 	.db 0x0a
      000002 53 54 4D 38 53 20 49   516 	.ascii "STM8S IR Receiver Ready"
             52 20 52 65 63 65 69
             76 65 72 20 52 65 61
             64 79
      000019 00                     517 	.db 0x00
                                    518 	.area CODE
                                    519 	.area CONST
      00001A                        520 ___str_2:
      00001A 4F 4B 20 2D 3E 20 41   521 	.ascii "OK -> Addr: 0x%02X, Cmd: 0x%02X, Raw: 0x%08lX"
             64 64 72 3A 20 30 78
             25 30 32 58 2C 20 43
             6D 64 3A 20 30 78 25
             30 32 58 2C 20 52 61
             77 3A 20 30 78 25 30
             38 6C 58
      000047 0A                     522 	.db 0x0a
      000048 00                     523 	.db 0x00
                                    524 	.area CODE
                                    525 	.area CONST
      000049                        526 ___str_3:
      000049 45 72 72 6F 72 20 2D   527 	.ascii "Error -> Raw: 0x%08lX"
             3E 20 52 61 77 3A 20
             30 78 25 30 38 6C 58
      00005E 0A                     528 	.db 0x0a
      00005F 00                     529 	.db 0x00
                                    530 	.area CODE
                                    531 	.area INITIALIZER
      000000                        532 __xinit__ir_state:
      000000 00                     533 	.db #0x00	; 0
      000001                        534 __xinit__ir_data:
      000001 00 00 00 00            535 	.byte #0x00, #0x00, #0x00, #0x00	; 0
      000005                        536 __xinit__ir_bit_count:
      000005 00                     537 	.db #0x00	; 0
      000006                        538 __xinit__ir_data_ready:
      000006 00                     539 	.db #0x00	; 0
                                    540 	.area CABS (ABS)
